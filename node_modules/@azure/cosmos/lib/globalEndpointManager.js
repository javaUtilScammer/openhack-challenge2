"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const common_1 = require("./common");
/**
 * @hidden
 * This internal class implements the logic for endpoint management for geo-replicated database accounts.
 * @property {object} client                       - The document client instance.
 * @property {string} defaultEndpoint              - The endpoint used to create the client instance.
 * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests
 *                                                   based on read/write operations.
 * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations
 *                                                   for read requests.
 * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.
 */
class GlobalEndpointManager {
    /**
     * @constructor GlobalEndpointManager
     * @param {object} options                          - The document client instance.
     */
    constructor(options, readDatabaseAccount) {
        this.readDatabaseAccount = readDatabaseAccount;
        this.defaultEndpoint = options.endpoint;
        this.readEndpoint = options.endpoint;
        this.writeEndpoint = options.endpoint;
        this.enableEndpointDiscovery = options.connectionPolicy.EnableEndpointDiscovery;
        this.preferredLocations = options.connectionPolicy.PreferredLocations;
        this.isEndpointCacheInitialized = false;
    }
    /**
     * Gets the current read endpoint from the endpoint cache.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {function} callback        - The callback function which takes readEndpoint(string) as an argument.
     */
    getReadEndpoint() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
                return this.readEndpoint;
            }
            else {
                return this.readEndpoint;
            }
        });
    }
    /**
     * Sets the current read endpoint.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {string} readEndpoint        - The endpoint to be set as readEndpoint.
     */
    setReadEndpoint(readEndpoint) {
        this.readEndpoint = readEndpoint;
    }
    /**
     * Gets the current write endpoint from the endpoint cache.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {function} callback        - The callback function which takes writeEndpoint(string) as an argument.
     */
    getWriteEndpoint() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isEndpointCacheInitialized) {
                yield this.refreshEndpointList();
                return this.writeEndpoint;
            }
            else {
                return this.writeEndpoint;
            }
        });
    }
    /**
     * Sets the current write endpoint.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {string} writeEndpoint        - The endpoint to be set as writeEndpoint.
     */
    setWriteEndpoint(writeEndpoint) {
        this.writeEndpoint = writeEndpoint;
    }
    /**
     * Refreshes the endpoint list by retrieving the writable and readable locations
     *  from the geo-replicated database account and then updating the locations cache.
     *   We skip the refreshing if EnableEndpointDiscovery is set to False
     * @memberof GlobalEndpointManager
     * @instance
     */
    refreshEndpointList() {
        return __awaiter(this, void 0, void 0, function* () {
            let writableLocations = [];
            let readableLocations = [];
            let databaseAccount;
            if (this.enableEndpointDiscovery) {
                databaseAccount = yield this._getDatabaseAccount();
                if (databaseAccount) {
                    writableLocations = databaseAccount.WritableLocations;
                    readableLocations = databaseAccount.ReadableLocations;
                }
                // Read and Write endpoints will be initialized to default endpoint if we were not able
                // to get the database account info
                [this.writeEndpoint, this.readEndpoint] = yield this._updateLocationsCache(writableLocations, readableLocations);
                this.isEndpointCacheInitialized = true;
                return [this.writeEndpoint, this.readEndpoint];
            }
            else {
                return [this.writeEndpoint, this.readEndpoint];
            }
        });
    }
    /**
     * Gets the database account first by using the default endpoint, and if that doesn't returns
     * use the endpoints for the preferred locations in the order they are specified to get
     * the database account.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.
     */
    _getDatabaseAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = { urlConnection: this.defaultEndpoint };
            try {
                const { result: databaseAccount } = yield this.readDatabaseAccount(options);
                return databaseAccount;
                // If for any reason(non - globaldb related), we are not able to get the database
                // account from the above call to readDatabaseAccount,
                // we would try to get this information from any of the preferred locations that the user
                // might have specified(by creating a locational endpoint)
                // and keeping eating the exception until we get the database account and return None at the end,
                // if we are not able to get that info from any endpoints
            }
            catch (err) {
                // TODO: error handling? Maybe at least tracing? Do we continue on all errors?
            }
            for (const location of this.preferredLocations) {
                try {
                    const locationalEndpoint = GlobalEndpointManager._getLocationalEndpoint(this.defaultEndpoint, location);
                    const innerOptions = { urlConnection: locationalEndpoint }; // TODO: code smell inner options is hacky
                    const { result: databaseAccount } = yield this.readDatabaseAccount(innerOptions);
                    if (databaseAccount) {
                        return databaseAccount;
                    }
                }
                catch (err) {
                    // TODO: probably need error handling here?
                }
            }
        });
    }
    /**
     * Gets the locational endpoint using the location name passed to it using the default endpoint.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {string} defaultEndpoint - The default endpoint to use for teh endpoint.
     * @param {string} locationName    - The location name for the azure region like "East US".
     */
    static _getLocationalEndpoint(defaultEndpoint, locationName) {
        // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format
        // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)
        // and we agreed to document that
        const endpointUrl = url.parse(defaultEndpoint, true, true);
        // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'
        if (endpointUrl.hostname) {
            const hostnameParts = endpointUrl.hostname
                .toString()
                .toLowerCase()
                .split(".");
            if (hostnameParts) {
                // globalDatabaseAccountName will return 'contoso'
                const globalDatabaseAccountName = hostnameParts[0];
                // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'
                const locationalDatabaseAccountName = globalDatabaseAccountName + "-" + locationName.replace(" ", "");
                // Replace 'contoso' with 'contoso-EastUS' and
                // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/
                const locationalEndpoint = defaultEndpoint
                    .toLowerCase()
                    .replace(globalDatabaseAccountName, locationalDatabaseAccountName);
                return locationalEndpoint;
            }
        }
        return null;
    }
    /**
     * Updates the read and write endpoints from the passed-in readable and writable locations.
     * @memberof GlobalEndpointManager
     * @instance
     * @param {Array} writableLocations     - The list of writable locations for the geo-enabled database account.
     * @param {Array} readableLocations     - The list of readable locations for the geo-enabled database account.
     * @param {function} callback           - The function to be called as callback after executing this method.
     */
    _updateLocationsCache(writableLocations, readableLocations) {
        return __awaiter(this, void 0, void 0, function* () {
            let writeEndpoint;
            let readEndpoint;
            // Use the default endpoint as Read and Write endpoints if EnableEndpointDiscovery
            // is set to False.
            if (!this.enableEndpointDiscovery) {
                writeEndpoint = this.defaultEndpoint;
                readEndpoint = this.defaultEndpoint;
                return [writeEndpoint, readEndpoint];
            }
            // Use the default endpoint as Write endpoint if there are no writable locations, or
            // first writable location as Write endpoint if there are writable locations
            writeEndpoint =
                writableLocations.length === 0 ? this.defaultEndpoint : writableLocations[0][common_1.Constants.DatabaseAccountEndpoint];
            // Why where we trying to access this like a dictionary? ;
            // Use the Write endpoint as Read endpoint if there are no readable locations
            if (readableLocations.length === 0) {
                readEndpoint = writeEndpoint;
                return [writeEndpoint, readEndpoint];
            }
            else {
                // Use the writable location as Read endpoint if there are no preferred locations or
                // none of the preferred locations are in read or write locations
                readEndpoint = writeEndpoint;
                if (!this.preferredLocations) {
                    return [writeEndpoint, readEndpoint];
                }
                for (const preferredLocation of this.preferredLocations) {
                    // Use the first readable location as Read endpoint from the preferred locations
                    for (const readLocation of readableLocations) {
                        if (readLocation[common_1.Constants.Name] === preferredLocation) {
                            readEndpoint = readLocation[common_1.Constants.DatabaseAccountEndpoint];
                            return [writeEndpoint, readEndpoint];
                        }
                    }
                    // Else, use the first writable location as Read endpoint from the preferred locations
                    for (const writeLocation of writableLocations) {
                        if (writeLocation[common_1.Constants.Name] === preferredLocation) {
                            readEndpoint = writeLocation[common_1.Constants.DatabaseAccountEndpoint];
                            return [writeEndpoint, readEndpoint];
                        }
                    }
                }
                return [writeEndpoint, readEndpoint];
            }
        });
    }
}
exports.GlobalEndpointManager = GlobalEndpointManager;
//# sourceMappingURL=globalEndpointManager.js.map