"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const queryExecutionContext_1 = require("./queryExecutionContext");
/**
 * Represents a QueryIterator Object, an implmenetation of feed or query response that enables
 * traversal and iterating over the response
 * in the Azure Cosmos DB database service.
 */
class QueryIterator {
    /**
     * @hidden
     */
    constructor(clientContext, query, options, // TODO: any options
    fetchFunctions, resourceLink) {
        this.clientContext = clientContext;
        this.query = query;
        this.options = options;
        this.fetchFunctions = fetchFunctions;
        this.resourceLink = resourceLink;
        this.query = query;
        this.fetchFunctions = fetchFunctions;
        this.options = options;
        this.resourceLink = resourceLink;
        this.queryExecutionContext = this._createQueryExecutionContext();
    }
    /**
     * Calls a specified callback for each item returned from the query.
     * Runs serially; each callback blocks the next.
     *
     * @param callback Specified callback.
     * First param is the result,
     * second param (optional) is the current headers object state,
     * third param (optional) is current index.
     * No more callbacks will be called if one of them results false.
     *
     * @returns Promise<void> - you should await or .catch the Promise in case there are any errors
     *
     * @example Iterate over all databases
     * ```typescript
     * await client.databases.readAll().forEach((db, headers, index) => {
     *   console.log(`Got ${db.id} from forEach`);
     * })
     * ```
     */
    forEach(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            let index = 0;
            while (this.queryExecutionContext.hasMoreResults()) {
                const result = yield this.queryExecutionContext.nextItem();
                if (result.result === undefined) {
                    return;
                }
                if (callback(result.result, result.headers, index) === false) {
                    return;
                }
                else {
                    ++index;
                }
            }
        });
    }
    /**
     * Gets an async iterator that will yield results until completion.
     *
     * NOTE: AsyncIterators are a very new feature and you might need to
     * use polyfils/etc. in order to use them in your code.
     *
     * If you're using TypeScript, you can use the following polyfill as long
     * as you target ES6 or higher and are running on Node 6 or higher.
     *
     * ```typescript
     * if (!Symbol || !Symbol.asyncIterator) {
     *   (Symbol as any).asyncIterator = Symbol.for("Symbol.asyncIterator");
     * }
     * ```
     *
     * @see QueryIterator.forEach for very similar functionality.
     *
     * @example Iterate over all databases
     * ```typescript
     * for await(const {result: db} in client.databases.readAll().getAsyncIterator()) {
     *   console.log(`Got ${db.id} from AsyncIterator`);
     * }
     * ```
     */
    getAsyncIterator() {
        return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {
            this.reset();
            while (this.queryExecutionContext.hasMoreResults()) {
                const result = yield __await(this.queryExecutionContext.nextItem());
                if (result.result === undefined) {
                    return yield __await(void 0);
                }
                yield yield __await(result);
            }
        });
    }
    /**
     * Execute a provided function on the next element in the QueryIterator.
     */
    nextItem() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryExecutionContext.nextItem();
        });
    }
    /**
     * Retrieve the current element on the QueryIterator.
     */
    current() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryExecutionContext.current();
        });
    }
    // TODO: why is has more results deprecated?
    /**
     * @deprecated Instead check if nextItem() or current() returns undefined.
     *
     * Determine if there are still remaining resources to processs based on the value of the continuation token or the\
     * elements remaining on the current batch in the QueryIterator.
     * @returns {Boolean} true if there is other elements to process in the QueryIterator.
     */
    hasMoreResults() {
        return this.queryExecutionContext.hasMoreResults();
    }
    /**
     * Retrieve all the elements of the feed and pass them as an array to a function
     */
    toArray() {
        return __awaiter(this, arguments, void 0, function* () {
            if (arguments.length !== 0) {
                throw new Error("toArray takes no arguments");
            }
            this.reset();
            this.toArrayTempResources = [];
            return this._toArrayImplementation();
        });
    }
    /**
     * Retrieve the next batch of the feed and pass them as an array to a function
     */
    executeNext() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryExecutionContext.fetchMore();
        });
    }
    /**
     * Reset the QueryIterator to the beginning and clear all the resources inside it
     */
    reset() {
        this.queryExecutionContext = this._createQueryExecutionContext();
    }
    _toArrayImplementation() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.queryExecutionContext.hasMoreResults()) {
                const { result, headers } = yield this.queryExecutionContext.nextItem();
                // concatinate the results and fetch more
                this.toArrayLastResHeaders = headers;
                if (result === undefined) {
                    // no more results
                    break;
                }
                this.toArrayTempResources.push(result);
            }
            return {
                result: this.toArrayTempResources,
                headers: this.toArrayLastResHeaders
            };
        });
    }
    _createQueryExecutionContext() {
        return new queryExecutionContext_1.ProxyQueryExecutionContext(this.clientContext, this.query, this.options, this.fetchFunctions, this.resourceLink);
    }
}
exports.QueryIterator = QueryIterator;
//# sourceMappingURL=queryIterator.js.map