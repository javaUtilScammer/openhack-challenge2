"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const common_1 = require("./common");
const documents_1 = require("./documents");
const request_1 = require("./request");
const request_2 = require("./request/request");
const sessionContainer_1 = require("./sessionContainer");
/**
 * @hidden
 * @ignore
 */
class ClientContext {
    constructor(cosmosClientOptions, globalEndpointManager) {
        this.cosmosClientOptions = cosmosClientOptions;
        this.globalEndpointManager = globalEndpointManager;
        this.connectionPolicy = cosmosClientOptions.connectionPolicy || new documents_1.ConnectionPolicy();
        this.sessionContainer = new sessionContainer_1.SessionContainer(cosmosClientOptions.endpoint);
        this.requestHandler = new request_1.RequestHandler(globalEndpointManager, this.connectionPolicy, this.cosmosClientOptions.agent);
        this.partitionKeyDefinitionCache = {};
    }
    /** @ignore */
    read(path, type, id, initialHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "get", path, id, type, options);
                this.applySessionToken(path, requestHeaders);
                const request = {
                    // TODO: any
                    path,
                    operationType: _1.Constants.OperationTypes.Read,
                    client: this,
                    endpointOverride: null
                };
                // read will use ReadEndpoint since it uses GET operation
                const readEndpoint = yield this.globalEndpointManager.getReadEndpoint();
                const response = yield this.requestHandler.get(readEndpoint, request, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Read, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    queryFeed(path, type, // TODO: code smell: enum?
    id, resultFn, // TODO: any
    query, options, partitionKeyRangeId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Query operations will use ReadEndpoint even though it uses
            // GET(for queryFeed) and POST(for regular query operations)
            const readEndpoint = yield this.globalEndpointManager.getReadEndpoint();
            const request = {
                // TODO: any request
                path,
                operationType: _1.Constants.OperationTypes.Query,
                client: this,
                endpointOverride: null
            };
            const initialHeaders = Object.assign({}, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders));
            if (query === undefined) {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "get", path, id, type, options, partitionKeyRangeId);
                this.applySessionToken(path, reqHeaders);
                const { result, headers: resHeaders } = yield this.requestHandler.get(readEndpoint, request, reqHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Query, resHeaders);
                return this.processQueryFeedResponse({ result, headers: resHeaders }, !!query, resultFn);
            }
            else {
                initialHeaders[_1.Constants.HttpHeaders.IsQuery] = "true";
                switch (this.cosmosClientOptions.queryCompatibilityMode) {
                    case documents_1.QueryCompatibilityMode.SqlQuery:
                        initialHeaders[_1.Constants.HttpHeaders.ContentType] = _1.Constants.MediaTypes.SQL;
                        break;
                    case documents_1.QueryCompatibilityMode.Query:
                    case documents_1.QueryCompatibilityMode.Default:
                    default:
                        if (typeof query === "string") {
                            query = { query }; // Converts query text to query object.
                        }
                        initialHeaders[_1.Constants.HttpHeaders.ContentType] = _1.Constants.MediaTypes.QueryJson;
                        break;
                }
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "post", path, id, type, options, partitionKeyRangeId);
                this.applySessionToken(path, reqHeaders);
                const response = yield this.requestHandler.post(readEndpoint, request, query, reqHeaders);
                const { result, headers: resHeaders } = response;
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Query, resHeaders);
                return this.processQueryFeedResponse({ result, headers: resHeaders }, !!query, resultFn);
            }
        });
    }
    queryPartitionKeyRanges(collectionLink, query, options) {
        const path = common_1.Helper.getPathFromLink(collectionLink, "pkranges");
        const id = common_1.Helper.getIdFromLink(collectionLink);
        const cb = innerOptions => {
            return this.queryFeed(path, "pkranges", id, result => result.PartitionKeyRanges, query, innerOptions);
        };
        return new _1.QueryIterator(this, query, options, cb);
    }
    delete(path, type, id, initialHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "delete", path, id, type, options);
                this.applySessionToken(path, reqHeaders);
                // deleteResource will use WriteEndpoint since it uses DELETE operation
                const writeEndpoint = yield this.globalEndpointManager.getWriteEndpoint();
                const response = yield this.requestHandler.delete(writeEndpoint, path, reqHeaders);
                if (common_1.Helper.parseLink(path).type !== "colls") {
                    this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Delete, response.headers);
                }
                else {
                    this.clearSessionToken(path);
                }
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    create(body, path, type, id, initialHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "post", path, id, type, options);
                // create will use WriteEndpoint since it uses POST operation
                this.applySessionToken(path, requestHeaders);
                const writeEndpoint = yield this.globalEndpointManager.getWriteEndpoint();
                const response = yield this.requestHandler.post(writeEndpoint, path, body, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Create, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    processQueryFeedResponse(res, isQuery, resultFn) {
        if (isQuery) {
            return { result: resultFn(res.result), headers: res.headers };
        }
        else {
            const newResult = resultFn(res.result).map((body) => body);
            return { result: newResult, headers: res.headers };
        }
    }
    applySessionToken(path, reqHeaders) {
        const request = this.getSessionParams(path);
        if (reqHeaders && reqHeaders[_1.Constants.HttpHeaders.SessionToken]) {
            return;
        }
        const sessionConsistency = reqHeaders[_1.Constants.HttpHeaders.ConsistencyLevel];
        if (!sessionConsistency) {
            return;
        }
        if (request["resourceAddress"]) {
            const sessionToken = this.sessionContainer.resolveGlobalSessionToken(request);
            if (sessionToken !== "") {
                reqHeaders[_1.Constants.HttpHeaders.SessionToken] = sessionToken;
            }
        }
    }
    replace(resource, path, type, id, initialHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "put", path, id, type, options);
                this.applySessionToken(path, reqHeaders);
                // replace will use WriteEndpoint since it uses PUT operation
                const writeEndpoint = yield this.globalEndpointManager.getWriteEndpoint();
                const response = yield this.requestHandler.put(writeEndpoint, path, resource, reqHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Replace, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    upsert(body, path, type, id, initialHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "post", path, id, type, options);
                common_1.Helper.setIsUpsertHeader(requestHeaders);
                this.applySessionToken(path, requestHeaders);
                // upsert will use WriteEndpoint since it uses POST operation
                const writeEndpoint = yield this.globalEndpointManager.getWriteEndpoint();
                const response = yield this.requestHandler.post(writeEndpoint, path, body, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Upsert, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    execute(sprocLink, params, // TODO: any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            const initialHeaders = Object.assign({}, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders));
            // Accept a single parameter or an array of parameters.
            // Didn't add type annotation for this because we should legacy this behavior
            if (params !== null && params !== undefined && !Array.isArray(params)) {
                params = [params];
            }
            const path = common_1.Helper.getPathFromLink(sprocLink);
            const id = common_1.Helper.getIdFromLink(sprocLink);
            const headers = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "post", path, id, "sprocs", options);
            // executeStoredProcedure will use WriteEndpoint since it uses POST operation
            const writeEndpoint = yield this.globalEndpointManager.getWriteEndpoint();
            return this.requestHandler.post(writeEndpoint, path, params, headers);
        });
    }
    /**
     * Gets the Database account information.
     * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. \
     * If not present, current client's url will be used.
     */
    getDatabaseAccount(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const urlConnection = options.urlConnection || this.cosmosClientOptions.endpoint;
            const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, this.cosmosClientOptions.defaultHeaders, "get", "", "", "", {});
            const { result, headers } = yield this.requestHandler.get(urlConnection, "", requestHeaders);
            const databaseAccount = new documents_1.DatabaseAccount();
            databaseAccount.DatabasesLink = "/dbs/";
            databaseAccount.MediaLink = "/media/";
            databaseAccount.MaxMediaStorageUsageInMB = headers[_1.Constants.HttpHeaders.MaxMediaStorageUsageInMB];
            databaseAccount.CurrentMediaStorageUsageInMB = headers[_1.Constants.HttpHeaders.CurrentMediaStorageUsageInMB];
            databaseAccount.ConsistencyPolicy = result.userConsistencyPolicy;
            // WritableLocations and ReadableLocations properties will be available
            // only for geo-replicated database accounts
            if (_1.Constants.WritableLocations in result && result.id !== "localhost") {
                databaseAccount._writableLocations = result[_1.Constants.WritableLocations];
            }
            if (_1.Constants.ReadableLocations in result && result.id !== "localhost") {
                databaseAccount._readableLocations = result[_1.Constants.ReadableLocations];
            }
            return { result: databaseAccount, headers };
        });
    }
    captureSessionToken(err, path, opType, resHeaders) {
        const request = this.getSessionParams(path); // TODO: any request
        request.operationType = opType;
        if (!err ||
            (!this.isMasterResource(request.resourceType) &&
                (err.code === common_1.StatusCodes.PreconditionFailed ||
                    err.code === common_1.StatusCodes.Conflict ||
                    (err.code === common_1.StatusCodes.NotFound && err.substatus !== common_1.SubStatusCodes.ReadSessionNotAvailable)))) {
            this.sessionContainer.setSessionToken(request, resHeaders);
        }
    }
    getSessionToken(collectionLink) {
        if (!collectionLink) {
            throw new Error("collectionLink cannot be null");
        }
        const paths = common_1.Helper.parseLink(collectionLink);
        if (paths === undefined) {
            return "";
        }
        const request = this.getSessionParams(collectionLink);
        return this.sessionContainer.resolveGlobalSessionToken(request);
    }
    clearSessionToken(path) {
        const request = this.getSessionParams(path);
        this.sessionContainer.clearToken(request);
    }
    getSessionParams(resourceLink) {
        const resourceId = null;
        let resourceAddress = null;
        const parserOutput = common_1.Helper.parseLink(resourceLink);
        resourceAddress = parserOutput.objectBody.self;
        const resourceType = parserOutput.type;
        return {
            resourceId,
            resourceAddress,
            resourceType,
            isNameBased: true
        };
    }
    isMasterResource(resourceType) {
        if (resourceType === _1.Constants.Path.OffersPathSegment ||
            resourceType === _1.Constants.Path.DatabasesPathSegment ||
            resourceType === _1.Constants.Path.UsersPathSegment ||
            resourceType === _1.Constants.Path.PermissionsPathSegment ||
            resourceType === _1.Constants.Path.TopologyPathSegment ||
            resourceType === _1.Constants.Path.DatabaseAccountPathSegment ||
            resourceType === _1.Constants.Path.PartitionKeyRangesPathSegment ||
            resourceType === _1.Constants.Path.CollectionsPathSegment) {
            return true;
        }
        return false;
    }
}
exports.ClientContext = ClientContext;
//# sourceMappingURL=ClientContext.js.map