"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const common_1 = require("../common");
const defaultRetryPolicy_1 = require("./defaultRetryPolicy");
/** @hidden */
class RetryUtility {
    /**
     * Executes the retry policy for the created request object.
     * @param {object} globalEndpointManager - an instance of GlobalEndpointManager class.
     * @param {object} body - a dictionary containing 'buffer' and 'stream' keys to hold corresponding buffer or\
     *  stream body, null otherwise.
     * @param {function} createRequestObjectStub - stub function that creates the request object.
     * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.
     * @param {RequestOptions} requestOptions - The request options.
     * @param {function} callback - the callback that will be called when the request is finished executing.
     */
    static execute(globalEndpointManager, body, createRequestObjectFunc, connectionPolicy, requestOptions, request) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: any request
            const r = typeof request !== "string" ? request : { path: "", operationType: "nonReadOps", client: null };
            const endpointDiscoveryRetryPolicy = new _1.EndpointDiscoveryRetryPolicy(globalEndpointManager);
            const resourceThrottleRetryPolicy = new _1.ResourceThrottleRetryPolicy(connectionPolicy.RetryOptions.MaxRetryAttemptCount, connectionPolicy.RetryOptions.FixedRetryIntervalInMilliseconds, connectionPolicy.RetryOptions.MaxWaitTimeInSeconds);
            const sessionReadRetryPolicy = new _1.SessionReadRetryPolicy(globalEndpointManager, r);
            const defaultRetryPolicy = new defaultRetryPolicy_1.DefaultRetryPolicy(request.operationType);
            return this.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy);
        });
    }
    /**
     * Applies the retry policy for the created request object.
     * @param {object} body - a dictionary containing 'buffer' and 'stream' keys to hold corresponding buffer or \
     * stream body, null otherwise.
     * @param {function} createRequestObjectFunc - function that creates the request object.
     * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.
     * @param {RequestOptions} requestOptions - The request options.
     * @param {EndpointDiscoveryRetryPolicy} endpointDiscoveryRetryPolicy - The endpoint discovery retry policy \
     * instance.
     * @param {ResourceThrottleRetryPolicy} resourceThrottleRetryPolicy - The resource throttle retry policy instance.
     * @param {function} callback - the callback that will be called when the response is retrieved and processed.
     */
    static apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: any response
            const httpsRequest = createRequestObjectFunc(connectionPolicy, requestOptions, body);
            try {
                const { result, headers } = yield httpsRequest;
                headers[common_1.Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;
                headers[common_1.Constants.ThrottleRetryWaitTimeInMs] = resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
                return { result, headers };
            }
            catch (err) {
                // TODO: any error
                let retryPolicy = null; // TODO: any Need an interface
                const headers = err.headers || {};
                if (err.code === common_1.StatusCodes.Forbidden && err.substatus === common_1.SubStatusCodes.WriteForbidden) {
                    retryPolicy = endpointDiscoveryRetryPolicy;
                }
                else if (err.code === common_1.StatusCodes.TooManyRequests) {
                    retryPolicy = resourceThrottleRetryPolicy;
                }
                else if (err.code === common_1.StatusCodes.NotFound && err.substatus === common_1.SubStatusCodes.ReadSessionNotAvailable) {
                    retryPolicy = sessionReadRetryPolicy;
                }
                else {
                    retryPolicy = defaultRetryPolicy;
                }
                const results = yield retryPolicy.shouldRetry(err);
                if (!results) {
                    headers[common_1.Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;
                    headers[common_1.Constants.ThrottleRetryWaitTimeInMs] = resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
                    err.headers = Object.assign({}, err.headers, headers);
                    throw err;
                }
                else {
                    const newUrl = results[1]; // TODO: any hack
                    return new Promise((resolve, reject) => {
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            if (typeof newUrl !== "undefined") {
                                requestOptions = this.modifyRequestOptions(requestOptions, newUrl);
                            }
                            resolve(yield this.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy));
                        }), retryPolicy.retryAfterInMilliseconds);
                    });
                }
            }
        });
    }
    static modifyRequestOptions(oldRequestOptions, // TODO: any hack is bad
    newUrl) {
        // TODO: any hack is bad
        const properties = Object.keys(newUrl);
        for (const index in properties) {
            if (properties[index] !== "path") {
                oldRequestOptions[properties[index]] = newUrl[properties[index]];
            }
        }
        return oldRequestOptions;
    }
}
exports.RetryUtility = RetryUtility;
//# sourceMappingURL=retryUtility.js.map