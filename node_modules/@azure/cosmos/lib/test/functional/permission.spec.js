"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("../..");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Permission CRUD", function () {
        const permissionCRUDTest = function (isUpsertTest) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create container & database
                    const container = yield TestHelpers_1.getTestContainer("Validate Permission Crud");
                    // create user
                    const { body: userDef } = yield container.database.users.create({ id: "new user" });
                    const user = container.database.user(userDef.id);
                    // list permissions
                    const { result: permissions } = yield user.permissions.readAll().toArray();
                    assert.equal(permissions.constructor, Array, "Value should be an array");
                    const beforeCreateCount = permissions.length;
                    const permissionDef = {
                        id: "new permission",
                        permissionMode: __1.DocumentBase.PermissionMode.Read,
                        resource: container.url
                    };
                    // create permission
                    const { body: createdPermission } = yield TestHelpers_1.createOrUpsertPermission(user, permissionDef, undefined, isUpsertTest);
                    let permission = user.permission(createdPermission.id);
                    assert.equal(createdPermission.id, "new permission", "permission name error");
                    // list permissions after creation
                    const { result: permissionsAfterCreation } = yield user.permissions.readAll().toArray();
                    assert.equal(permissionsAfterCreation.length, beforeCreateCount + 1);
                    // query permissions
                    const querySpec = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: permissionDef.id
                            }
                        ]
                    };
                    const { result: results } = yield user.permissions.query(querySpec).toArray();
                    assert(results.length > 0, "number of results for the query should be > 0");
                    permissionDef.permissionMode = __1.DocumentBase.PermissionMode.All;
                    const { body: replacedPermission } = yield TestHelpers_1.replaceOrUpsertPermission(user, permissionDef, undefined, isUpsertTest);
                    assert.equal(replacedPermission.permissionMode, __1.DocumentBase.PermissionMode.All, "permission mode should change");
                    assert.equal(permissionDef.id, replacedPermission.id, "permission id should stay the same");
                    // to change the id of an existing resourcewe have to use replace
                    permissionDef.id = "replaced permission";
                    const { body: replacedPermission2 } = yield permission.replace(permissionDef);
                    assert.equal(replacedPermission2.id, "replaced permission", "permission name should change");
                    assert.equal(permissionDef.id, replacedPermission2.id, "permission id should stay the same");
                    permission = user.permission(replacedPermission2.id);
                    // read permission
                    const { body: permissionAfterReplace } = yield permission.read();
                    assert.equal(permissionAfterReplace.id, permissionDef.id);
                    // delete permission
                    const { body: res } = yield permission.delete();
                    // read permission after deletion
                    try {
                        yield permission.read();
                        assert.fail("Must fail to read permission after deletion");
                    }
                    catch (err) {
                        const notFoundErrorCode = 404;
                        assert.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const permissionCRUDOverMultiplePartitionsTest = function (isUpsertTest) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    // create container
                    const partitionKey = "id";
                    const containerDefinition = {
                        id: "coll1",
                        partitionKey: { paths: ["/" + partitionKey], kind: __1.DocumentBase.PartitionKind.Hash }
                    };
                    const container = yield TestHelpers_1.getTestContainer("permission CRUD over multiple partitions", undefined, containerDefinition);
                    // create user
                    const { body: userDef } = yield container.database.users.create({ id: "new user" });
                    const user = container.database.user(userDef.id);
                    // list permissions
                    const { result: permissions } = yield user.permissions.readAll().toArray();
                    assert(Array.isArray(permissions), "Value should be an array");
                    const beforeCreateCount = permissions.length;
                    const permissionDefinition = {
                        id: "new permission",
                        permissionMode: __1.DocumentBase.PermissionMode.Read,
                        resource: container.url,
                        resourcePartitionKey: [1]
                    };
                    // create permission
                    const response = yield TestHelpers_1.createOrUpsertPermission(user, permissionDefinition, undefined, isUpsertTest);
                    const permissionDef = response.body;
                    let permission = user.permission(permissionDef.id);
                    assert.equal(permissionDef.id, permissionDefinition.id, "permission name error");
                    assert.equal(JSON.stringify(permissionDef.resourcePartitionKey), JSON.stringify(permissionDefinition.resourcePartitionKey), "permission resource partition key error");
                    // list permissions after creation
                    const { result: permissionsAfterCreation } = yield user.permissions.readAll().toArray();
                    assert.equal(permissionsAfterCreation.length, beforeCreateCount + 1);
                    // query permissions
                    const querySpec = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: permissionDef.id
                            }
                        ]
                    };
                    const { result: results } = yield user.permissions.query(querySpec).toArray();
                    assert(results.length > 0, "number of results for the query should be > 0");
                    // Replace permission
                    permissionDef.permissionMode = __1.DocumentBase.PermissionMode.All;
                    const { body: replacedPermission } = yield TestHelpers_1.replaceOrUpsertPermission(user, permissionDef, undefined, isUpsertTest);
                    assert.equal(replacedPermission.permissionMode, __1.DocumentBase.PermissionMode.All, "permission mode should change");
                    assert.equal(replacedPermission.id, permissionDef.id, "permission id should stay the same");
                    assert.equal(JSON.stringify(replacedPermission.resourcePartitionKey), JSON.stringify(permissionDef.resourcePartitionKey), "permission resource partition key error");
                    // to change the id of an existing resourcewe have to use replace
                    permissionDef.id = "replaced permission";
                    const { body: replacedPermission2 } = yield permission.replace(permissionDef);
                    assert.equal(replacedPermission2.id, permissionDef.id);
                    permission = user.permission(replacedPermission2.id);
                    // read permission
                    const { body: permissionAfterReplace } = yield permission.read();
                    assert.equal(permissionAfterReplace.id, replacedPermission2.id);
                    // delete permission
                    const { body: res } = yield permission.delete();
                    // read permission after deletion
                    try {
                        yield permission.read();
                        assert.fail("Must throw on read after delete");
                    }
                    catch (err) {
                        const notFoundErrorCode = 404;
                        assert.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should do Permission CRUD operations successfully name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield permissionCRUDTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should do Permission CRUD operations successfully name based with upsert", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield permissionCRUDTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should do Permission CRUD operations over multiple partitions successfully name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield permissionCRUDOverMultiplePartitionsTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should do Permission CRUD operations over multiple partitions successfully with upsert", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield permissionCRUDOverMultiplePartitionsTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
});
//# sourceMappingURL=permission.spec.js.map