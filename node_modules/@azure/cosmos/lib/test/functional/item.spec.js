"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("../..");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Document CRUD", function () {
        const documentCRUDTest = function (isUpsertTest) {
            return __awaiter(this, void 0, void 0, function* () {
                // create database
                const database = yield TestHelpers_1.getTestDatabase("sample 中文 database");
                // create container
                const { body: containerdef } = yield database.containers.create({ id: "sample container" });
                const container = database.container(containerdef.id);
                // read items
                const { result: items } = yield container.items.readAll().toArray();
                assert(Array.isArray(items), "Value should be an array");
                // create an item
                const beforeCreateDocumentsCount = items.length;
                const itemDefinition = {
                    name: "sample document",
                    foo: "bar",
                    key: "value",
                    replace: "new property"
                };
                try {
                    yield TestHelpers_1.createOrUpsertItem(container, itemDefinition, { disableAutomaticIdGeneration: true }, isUpsertTest);
                    assert.fail("id generation disabled must throw with invalid id");
                }
                catch (err) {
                    assert(err !== undefined, "should throw an error because automatic id generation is disabled");
                }
                const { body: document } = yield TestHelpers_1.createOrUpsertItem(container, itemDefinition, undefined, isUpsertTest);
                assert.equal(document.name, itemDefinition.name);
                assert(document.id !== undefined);
                // read documents after creation
                const { result: documents2 } = yield container.items.readAll().toArray();
                assert.equal(documents2.length, beforeCreateDocumentsCount + 1, "create should increase the number of documents");
                // query documents
                const querySpec = {
                    query: "SELECT * FROM root r WHERE r.id=@id",
                    parameters: [
                        {
                            name: "@id",
                            value: document.id
                        }
                    ]
                };
                const { result: results } = yield container.items.query(querySpec).toArray();
                assert(results.length > 0, "number of results for the query should be > 0");
                const { result: results2 } = yield container.items.query(querySpec, { enableScanInQuery: true }).toArray();
                assert(results2.length > 0, "number of results for the query should be > 0");
                // replace document
                document.name = "replaced document";
                document.foo = "not bar";
                const { body: replacedDocument } = yield TestHelpers_1.replaceOrUpsertItem(container, document, undefined, isUpsertTest);
                assert.equal(replacedDocument.name, "replaced document", "document name property should change");
                assert.equal(replacedDocument.foo, "not bar", "property should have changed");
                assert.equal(document.id, replacedDocument.id, "document id should stay the same");
                // read document
                const { body: document2 } = yield container.item(replacedDocument.id).read();
                assert.equal(replacedDocument.id, document2.id);
                // delete document
                const { body: res } = yield container.item(replacedDocument.id).delete();
                // read documents after deletion
                try {
                    const { body: document3 } = yield container.item(replacedDocument.id).read();
                    assert.fail("must throw if document doesn't exist");
                }
                catch (err) {
                    const notFoundErrorCode = 404;
                    assert.equal(err.code, notFoundErrorCode, "response should return error code 404");
                }
            });
        };
        const documentCRUDMultiplePartitionsTest = function () {
            return __awaiter(this, void 0, void 0, function* () {
                // create database
                const database = yield TestHelpers_1.getTestDatabase("db1");
                const partitionKey = "key";
                // create container
                const containerDefinition = {
                    id: "coll1",
                    partitionKey: { paths: ["/" + partitionKey], kind: __1.DocumentBase.PartitionKind.Hash }
                };
                const { body: containerdef } = yield database.containers.create(containerDefinition, { offerThroughput: 12000 });
                const container = database.container(containerdef.id);
                const documents = [
                    { id: "document1" },
                    { id: "document2", key: null, prop: 1 },
                    { id: "document3", key: false, prop: 1 },
                    { id: "document4", key: true, prop: 1 },
                    { id: "document5", key: 1, prop: 1 },
                    { id: "document6", key: "A", prop: 1 }
                ];
                let returnedDocuments = yield TestHelpers_1.bulkInsertItems(container, documents);
                assert.equal(returnedDocuments.length, documents.length);
                returnedDocuments.sort(function (doc1, doc2) {
                    return doc1.id.localeCompare(doc2.id);
                });
                yield TestHelpers_1.bulkReadItems(container, returnedDocuments, partitionKey);
                const { result: successDocuments } = yield container.items.readAll().toArray();
                assert(successDocuments !== undefined, "error reading documents");
                assert.equal(successDocuments.length, returnedDocuments.length, "Expected " + returnedDocuments.length + " documents to be succesfully read");
                successDocuments.sort(function (doc1, doc2) {
                    return doc1.id.localeCompare(doc2.id);
                });
                assert.equal(JSON.stringify(successDocuments), JSON.stringify(returnedDocuments), "Unexpected documents are returned");
                returnedDocuments.forEach(function (document) {
                    ++document.prop;
                });
                const newReturnedDocuments = yield TestHelpers_1.bulkReplaceItems(container, returnedDocuments);
                returnedDocuments = newReturnedDocuments;
                yield TestHelpers_1.bulkQueryItemsWithPartitionKey(container, returnedDocuments, partitionKey);
                const querySpec = {
                    query: "SELECT * FROM Root"
                };
                try {
                    const { result: badUpdate } = yield container.items.query(querySpec, { enableScanInQuery: true }).toArray();
                    assert.fail("Must fail");
                }
                catch (err) {
                    const badRequestErrorCode = 400;
                    assert.equal(err.code, badRequestErrorCode, "response should return error code " + badRequestErrorCode);
                }
                const { result: results } = yield container.items
                    .query(querySpec, { enableScanInQuery: true, enableCrossPartitionQuery: true })
                    .toArray();
                assert(results !== undefined, "error querying documents");
                results.sort(function (doc1, doc2) {
                    return doc1.id.localeCompare(doc2.id);
                });
                assert.equal(results.length, returnedDocuments.length, "Expected " + returnedDocuments.length + " documents to be succesfully queried");
                assert.equal(JSON.stringify(results), JSON.stringify(returnedDocuments), "Unexpected query results");
                yield TestHelpers_1.bulkDeleteItems(container, returnedDocuments, partitionKey);
            });
        };
        it("nativeApi Should do document CRUD operations successfully name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield documentCRUDTest(false);
            });
        });
        it("nativeApi Should do document CRUD operations successfully name based with upsert", function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield documentCRUDTest(true);
            });
        });
        it("nativeApi Should do document CRUD operations over multiple partitions", function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield documentCRUDMultiplePartitionsTest();
            });
        });
    });
});
//# sourceMappingURL=item.spec.js.map