"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("../..");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate spatial index", function () {
        const spatialIndexTest = function (isUpsertTest) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("validate spatial index");
                    // create container using an indexing policy with spatial index.
                    const indexingPolicy = {
                        includedPaths: [
                            {
                                path: '/"Location"/?',
                                indexes: [
                                    {
                                        kind: __1.DocumentBase.IndexKind.Spatial,
                                        dataType: __1.DocumentBase.DataType.Point
                                    }
                                ]
                            },
                            {
                                path: "/"
                            }
                        ]
                    };
                    const entropy = Math.floor(Math.random() * 10000);
                    const { body: containerDef } = yield database.containers.create({
                        id: `sample container${entropy}`,
                        indexingPolicy
                    });
                    const container = database.container(containerDef.id);
                    const location1 = {
                        id: "location1",
                        Location: {
                            type: "Point",
                            coordinates: [20.0, 20.0]
                        }
                    };
                    yield TestHelpers_1.createOrUpsertItem(container, location1, undefined, isUpsertTest);
                    const location2 = {
                        id: "location2",
                        Location: {
                            type: "Point",
                            coordinates: [100.0, 100.0]
                        }
                    };
                    yield TestHelpers_1.createOrUpsertItem(container, location2, undefined, isUpsertTest);
                    const query = "SELECT * FROM root WHERE (ST_DISTANCE(root.Location, {type: 'Point', coordinates: [20.1, 20]}) < 20000) ";
                    const { result: results } = yield container.items.query(query).toArray();
                    assert.equal(1, results.length);
                    assert.equal("location1", results[0].id);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should support spatial index name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield spatialIndexTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should support spatial index name based with upsert", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield spatialIndexTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
});
//# sourceMappingURL=spatial.spec.js.map