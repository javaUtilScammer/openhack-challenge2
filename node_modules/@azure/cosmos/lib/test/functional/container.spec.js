"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("../..");
const documents_1 = require("../../documents");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Container CRUD", function () {
        const containerCRUDTest = function (hasPartitionKey) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("Validate Container CRUD");
                    // create a container
                    const containerDefinition = {
                        id: "sample container",
                        indexingPolicy: { indexingMode: documents_1.IndexingMode.consistent }
                    };
                    if (hasPartitionKey) {
                        containerDefinition.partitionKey = { paths: ["/id"], kind: __1.DocumentBase.PartitionKind.Hash };
                    }
                    const { body: containerDef } = yield database.containers.create(containerDefinition);
                    const container = database.container(containerDef.id);
                    assert.equal(containerDefinition.id, containerDef.id);
                    assert.equal("consistent", containerDef.indexingPolicy.indexingMode);
                    assert.equal(JSON.stringify(containerDef.partitionKey), JSON.stringify(containerDefinition.partitionKey));
                    // read containers after creation
                    const { result: containers } = yield database.containers.readAll().toArray();
                    assert.equal(containers.length, 1, "create should increase the number of containers");
                    // query containers
                    const querySpec = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: containerDefinition.id
                            }
                        ]
                    };
                    const { result: results } = yield database.containers.query(querySpec).toArray();
                    assert(results.length > 0, "number of results for the query should be > 0");
                    // Replacing indexing policy is allowed.
                    containerDef.indexingPolicy.indexingMode = documents_1.IndexingMode.lazy;
                    const { body: replacedContainer } = yield container.replace(containerDef);
                    assert.equal("lazy", replacedContainer.indexingPolicy.indexingMode);
                    // Replacing partition key is not allowed.
                    try {
                        containerDef.partitionKey = { paths: ["/key"], kind: __1.DocumentBase.PartitionKind.Hash };
                        yield container.replace(containerDef);
                        assert.fail("Replacing paritionkey must throw");
                    }
                    catch (err) {
                        const badRequestErrorCode = 400;
                        assert.equal(err.code, badRequestErrorCode, "response should return error code " + badRequestErrorCode);
                    }
                    finally {
                        containerDef.partitionKey = containerDefinition.partitionKey; // Resume partition key
                    }
                    // Replacing id is not allowed.
                    try {
                        containerDef.id = "try_to_replace_id";
                        yield container.replace(containerDef);
                        assert.fail("Replacing container id must throw");
                    }
                    catch (err) {
                        const notFoundErrorCode = 400;
                        assert.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                    // read container
                    containerDef.id = containerDefinition.id; // Resume Id.
                    const { body: readcontainer } = yield container.read();
                    assert.equal(containerDefinition.id, readcontainer.id);
                    // delete container
                    yield container.delete();
                    // read container after deletion
                    try {
                        yield container.read();
                        assert.fail("Must fail to read container after delete");
                    }
                    catch (err) {
                        const notFoundErrorCode = 404;
                        assert.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const badPartitionKeyDefinitionTest = function (isNameBased) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("container CRUD bad partition key");
                    // create a container
                    const badPartitionKeyDefinition = {
                        paths: "/id",
                        kind: __1.DocumentBase.PartitionKind.Hash
                    };
                    const containerDefinition = {
                        id: "sample container",
                        indexingPolicy: { indexingMode: documents_1.IndexingMode.consistent },
                        partitionKey: badPartitionKeyDefinition // This is invalid, forced using type coersion
                    };
                    try {
                        yield database.containers.create(containerDefinition);
                    }
                    catch (err) {
                        assert.equal(err.code, 400);
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should do container CRUD operations successfully name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield containerCRUDTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should do elastic container CRUD operations successfully name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield containerCRUDTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi container with bad partition key definition name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield badPartitionKeyDefinitionTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi container with bad partition key definition name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield badPartitionKeyDefinitionTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Validate container indexing policy", function () {
        const indexPolicyTest = function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("container test database");
                    // create container
                    const { body: containerDef } = yield database.containers.create({ id: "container test container" });
                    const container = database.container(containerDef.id);
                    assert.equal(containerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.consistent, "default indexing mode should be consistent");
                    yield container.delete();
                    const lazyContainerDefinition = {
                        id: "lazy container",
                        indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.lazy }
                    };
                    const { body: lazyContainerDef } = yield database.containers.create(lazyContainerDefinition);
                    const lazyContainer = database.container(lazyContainerDef.id);
                    assert.equal(lazyContainerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.lazy, "indexing mode should be lazy");
                    yield lazyContainer.delete();
                    const consistentcontainerDefinition = {
                        id: "lazy container",
                        indexingPolicy: { indexingMode: "consistent" } // tests the type flexibility
                    };
                    const { body: consistentContainerDef } = yield database.containers.create(consistentcontainerDefinition);
                    const consistentContainer = database.container(consistentContainerDef.id);
                    assert.equal(containerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.consistent, "indexing mode should be consistent");
                    yield consistentContainer.delete();
                    const containerDefinition = {
                        id: "containerWithIndexingPolicy",
                        indexingPolicy: {
                            automatic: true,
                            indexingMode: __1.DocumentBase.IndexingMode.consistent,
                            includedPaths: [
                                {
                                    path: "/",
                                    indexes: [
                                        {
                                            kind: __1.DocumentBase.IndexKind.Hash,
                                            dataType: __1.DocumentBase.DataType.Number,
                                            precision: 2
                                        }
                                    ]
                                }
                            ],
                            excludedPaths: [
                                {
                                    path: '/"systemMetadata"/*'
                                }
                            ]
                        }
                    };
                    const { body: containerWithIndexingPolicyDef } = yield database.containers.create(containerDefinition);
                    // Two included paths.
                    assert.equal(1, containerWithIndexingPolicyDef.indexingPolicy.includedPaths.length, "Unexpected includedPaths length");
                    // The first included path is what we created.
                    assert.equal("/", containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].path);
                    // Backend adds a default index
                    assert(containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].indexes.length > 1);
                    assert.equal(__1.DocumentBase.IndexKind.Hash, containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].indexes[0].kind);
                    // The second included path is a timestamp index created by the server.
                    // And one excluded path.
                    assert.equal(1, containerWithIndexingPolicyDef.indexingPolicy.excludedPaths.length, "Unexpected excludedPaths length");
                    assert.equal('/"systemMetadata"/*', containerWithIndexingPolicyDef.indexingPolicy.excludedPaths[0].path);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should create container with correct indexing policy name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield indexPolicyTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
        const checkDefaultIndexingPolicyPaths = function (indexingPolicy) {
            // no excluded paths.
            assert.equal(0, indexingPolicy["excludedPaths"].length);
            // included paths should be 1 "/".
            assert.equal(1, indexingPolicy["includedPaths"].length);
            let rootIncludedPath = null;
            if (indexingPolicy["includedPaths"][0]["path"] === "/*") {
                rootIncludedPath = indexingPolicy["includedPaths"][0];
            }
            assert(rootIncludedPath); // root path should exist.
            // In the root path, there should be one HashIndex for Strings, and one RangeIndex for Numbers.
            assert.equal(2, rootIncludedPath["indexes"].length);
            let hashIndex = null;
            let rangeIndex = null;
            for (let i = 0; i < 2; ++i) {
                if (rootIncludedPath["indexes"][i]["kind"] === "Hash") {
                    hashIndex = rootIncludedPath["indexes"][i];
                }
                else if (rootIncludedPath["indexes"][i]["kind"] === "Range") {
                    rangeIndex = rootIncludedPath["indexes"][i];
                }
            }
            assert(hashIndex);
            assert.equal("String", hashIndex["dataType"]);
            assert(rangeIndex);
            assert.equal("Number", rangeIndex["dataType"]);
        };
        const defaultIndexingPolicyTest = function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("container test database");
                    // create container with no indexing policy specified.
                    const containerDefinition01 = { id: "TestCreateDefaultPolicy01" };
                    const { body: containerNoIndexPolicyDef } = yield database.containers.create(containerDefinition01);
                    checkDefaultIndexingPolicyPaths(containerNoIndexPolicyDef["indexingPolicy"]);
                    // create container with partial policy specified.
                    const containerDefinition02 = {
                        id: "TestCreateDefaultPolicy02",
                        indexingPolicy: {
                            indexingMode: documents_1.IndexingMode.lazy,
                            automatic: true
                        }
                    };
                    const { body: containerWithPartialPolicyDef } = yield database.containers.create(containerDefinition02);
                    checkDefaultIndexingPolicyPaths(containerWithPartialPolicyDef["indexingPolicy"]);
                    // create container with default policy.
                    const containerDefinition03 = {
                        id: "TestCreateDefaultPolicy03",
                        indexingPolicy: {}
                    };
                    const { body: containerDefaultPolicy } = yield database.containers.create(containerDefinition03);
                    checkDefaultIndexingPolicyPaths(containerDefaultPolicy["indexingPolicy"]);
                    // create container with indexing policy missing indexes.
                    const containerDefinition04 = {
                        id: "TestCreateDefaultPolicy04",
                        indexingPolicy: {
                            includedPaths: [
                                {
                                    path: "/*"
                                }
                            ]
                        }
                    };
                    const { body: containerMissingIndexes } = yield database.containers.create(containerDefinition04);
                    checkDefaultIndexingPolicyPaths(containerMissingIndexes["indexingPolicy"]);
                    // create container with indexing policy missing precision.
                    const containerDefinition05 = {
                        id: "TestCreateDefaultPolicy05",
                        indexingPolicy: {
                            includedPaths: [
                                {
                                    path: "/*",
                                    indexes: [
                                        {
                                            kind: documents_1.IndexKind.Hash,
                                            dataType: documents_1.DataType.String
                                        },
                                        {
                                            kind: documents_1.IndexKind.Range,
                                            dataType: documents_1.DataType.Number
                                        }
                                    ]
                                }
                            ]
                        }
                    };
                    const { body: containerMissingPrecision } = yield database.containers.create(containerDefinition05);
                    checkDefaultIndexingPolicyPaths(containerMissingPrecision["indexingPolicy"]);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should create container with default indexing policy name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield defaultIndexingPolicyTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Validate response headers", function () {
        const createThenReadcontainer = function (database, body) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const { body: createdcontainer, headers } = yield database.containers.create(body);
                    const response = yield database.container(createdcontainer.id).read();
                    return response;
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const indexProgressHeadersTest = function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const database = yield TestHelpers_1.getTestDatabase("Validate response headers");
                    const { headers: headers1 } = yield createThenReadcontainer(database, { id: "consistent_coll" });
                    assert.notEqual(headers1[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert.equal(headers1[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                    const lazyContainerDefinition = {
                        id: "lazy_coll",
                        indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.lazy }
                    };
                    const { headers: headers2 } = yield createThenReadcontainer(database, lazyContainerDefinition);
                    assert.notEqual(headers2[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert.notEqual(headers2[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                    const noneContainerDefinition = {
                        id: "none_coll",
                        indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.none, automatic: false }
                    };
                    const { headers: headers3 } = yield createThenReadcontainer(database, noneContainerDefinition);
                    assert.notEqual(headers3[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert.equal(headers3[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Validate index progress headers name based", function () {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield indexProgressHeadersTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
});
describe("container.createIfNotExists", function () {
    let database;
    before(function () {
        return __awaiter(this, void 0, void 0, function* () {
            // create database
            database = yield TestHelpers_1.getTestDatabase("container.createIfNotExists");
        });
    });
    it("should handle container does not exist", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const def = { id: "does not exist" };
            const { container } = yield database.containers.createIfNotExists(def);
            const { body: readDef } = yield container.read();
            assert.equal(def.id, readDef.id);
        });
    });
    it("should handle container exists", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const def = { id: "does exist" };
            yield database.containers.create(def);
            const { container } = yield database.containers.createIfNotExists(def);
            const { body: readDef } = yield container.read();
            assert.equal(def.id, readDef.id);
        });
    });
});
//# sourceMappingURL=container.spec.js.map