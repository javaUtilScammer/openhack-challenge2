"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const _ = require("underscore");
const util = require("util");
const __1 = require("../..");
const documents_1 = require("../../documents");
const TestHelpers_1 = require("../common/TestHelpers");
describe("Cross Partition", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || "30000");
    const generateDocuments = function (docSize) {
        const docs = [];
        for (let i = 0; i < docSize; i++) {
            const d = {
                id: i.toString(),
                name: "sample document",
                spam: "eggs" + i.toString(),
                cnt: i,
                key: "value",
                spam2: i === 3 ? "eggs" + i.toString() : i,
                boolVar: i % 2 === 0,
                number: 1.1 * i
            };
            docs.push(d);
        }
        return docs;
    };
    describe("Validate Query", function () {
        const documentDefinitions = generateDocuments(20);
        const containerDefinition = {
            id: "sample container",
            indexingPolicy: {
                includedPaths: [
                    {
                        path: "/",
                        indexes: [
                            {
                                kind: documents_1.IndexKind.Range,
                                dataType: documents_1.DataType.Number
                            },
                            {
                                kind: documents_1.IndexKind.Range,
                                dataType: documents_1.DataType.String
                            }
                        ]
                    }
                ]
            },
            partitionKey: {
                paths: ["/id"],
                kind: documents_1.PartitionKind.Hash
            }
        };
        const containerOptions = { offerThroughput: 10100 };
        let container;
        // - removes all the databases,
        // - creates a new database,
        // - creates a new collecton,
        // - bulk inserts documents to the container
        before(function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield TestHelpers_1.removeAllDatabases();
                container = yield TestHelpers_1.getTestContainer("Validate 中文 Query", undefined, containerDefinition, containerOptions);
                yield TestHelpers_1.bulkInsertItems(container, documentDefinitions);
            });
        });
        const validateResults = function (actualResults, expectedOrderIds) {
            assert.equal(actualResults.length, expectedOrderIds.length, "actual results length doesn't match with expected results length.");
            for (let i = 0; i < actualResults.length; i++) {
                assert.equal(actualResults[i].id, expectedOrderIds[i], "actual result content doesn't match with expected result content. " +
                    actualResults[i].id +
                    " != " +
                    expectedOrderIds[i]);
            }
        };
        const validateToArray = function (queryIterator, options, expectedOrderIds) {
            return __awaiter(this, void 0, void 0, function* () {
                ////////////////////////////////
                // validate toArray()
                ////////////////////////////////
                options.continuation = undefined;
                try {
                    const { result: results } = yield queryIterator.toArray();
                    assert.equal(results.length, expectedOrderIds.length, "invalid number of results");
                    assert.equal(queryIterator.hasMoreResults(), false, "hasMoreResults: no more results is left");
                    return validateResults(results, expectedOrderIds);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const validateNextItem = function (queryIterator, expectedOrderIds) {
            return __awaiter(this, void 0, void 0, function* () {
                ////////////////////////////////
                // validate nextItem()
                ////////////////////////////////
                const results = [];
                try {
                    while (results.length < expectedOrderIds.length) {
                        assert(queryIterator.hasMoreResults(), "hasMoreResults must indicate more results");
                        const { result: item } = yield queryIterator.nextItem();
                        if (item === undefined) {
                            break;
                        }
                        results.push(item);
                    }
                    assert(!queryIterator.hasMoreResults(), "hasMoreResults must signal results exhausted");
                    validateResults(results, expectedOrderIds);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const validateNextItemAndCurrentAndHasMoreResults = function (queryIterator, expectedOrderIds) {
            return __awaiter(this, void 0, void 0, function* () {
                // curent and nextItem recursively invoke each other till queryIterator is exhausted
                ////////////////////////////////
                // validate nextItem()
                ////////////////////////////////
                const results = [];
                try {
                    while (results.length <= expectedOrderIds.length) {
                        const { result: currentItem } = yield queryIterator.current();
                        const { result: item } = yield queryIterator.nextItem();
                        if (!item) {
                            break;
                        }
                        results.push(item);
                        if (results.length < expectedOrderIds.length) {
                            assert(queryIterator.hasMoreResults(), "hasMoreResults must indicate more results");
                        }
                        assert.equal(item, currentItem, "current must give the previously item returned by nextItem");
                    }
                    assert(!queryIterator.hasMoreResults(), "hasMoreResults must signal results exhausted");
                    validateResults(results, expectedOrderIds);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const validateExecuteNextAndHasMoreResults = function (options, queryIterator, expectedOrderIds, validateExecuteNextWithContinuationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                const pageSize = options["maxItemCount"];
                ////////////////////////////////
                // validate executeNext()
                ////////////////////////////////
                const listOfResultPages = [];
                const listOfHeaders = [];
                let totalFetchedResults = [];
                try {
                    while (totalFetchedResults.length <= expectedOrderIds.length) {
                        const { result: results, headers } = yield queryIterator.executeNext();
                        listOfResultPages.push(results);
                        listOfHeaders.push(headers);
                        if (results === undefined || totalFetchedResults.length === expectedOrderIds.length) {
                            break;
                        }
                        totalFetchedResults = totalFetchedResults.concat(results);
                        if (totalFetchedResults.length < expectedOrderIds.length) {
                            // there are more results
                            assert(results.length <= pageSize, "executeNext: invalid fetch block size");
                            if (validateExecuteNextWithContinuationToken) {
                                assert(results.length <= pageSize, "executeNext: invalid fetch block size");
                            }
                            else {
                                assert.equal(results.length, pageSize, "executeNext: invalid fetch block size");
                            }
                            assert(queryIterator.hasMoreResults(), "hasMoreResults expects to return true");
                        }
                        else {
                            // no more results
                            assert.equal(expectedOrderIds.length, totalFetchedResults.length, "executeNext: didn't fetch all the results");
                            assert(results.length <= pageSize, "executeNext: actual fetch size is more than the requested page size");
                        }
                    }
                    // no more results
                    validateResults(totalFetchedResults, expectedOrderIds);
                    assert.equal(queryIterator.hasMoreResults(), false, "hasMoreResults: no more results is left");
                    if (validateExecuteNextWithContinuationToken) {
                        // TODO: chrande
                        // I don't think this code is ever called, which means we're missing tests or should delete it.
                        throw new Error("Not yet implemented");
                        // return validateExecuteNextWithGivenContinuationToken(
                        //     containerLink, query, options, listOfResultPages, listOfHeaders);
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const validateForEach = function (queryIterator, expectedOrderIds) {
            return __awaiter(this, void 0, void 0, function* () {
                var e_1, _a;
                ////////////////////////////////
                // validate forEach()
                ////////////////////////////////
                const results = [];
                let callbackSingnalledEnd = false;
                try {
                    // forEach uses callbacks still, so just wrap in a promise
                    for (var _b = __asyncValues(queryIterator.getAsyncIterator()), _c; _c = yield _b.next(), !_c.done;) {
                        const { result: item } = _c.value;
                        // if the previous invocation returned false, forEach must avoid invoking the callback again!
                        assert.equal(callbackSingnalledEnd, false, "forEach called callback after the first false returned");
                        results.push(item);
                        if (results.length === expectedOrderIds.length) {
                            callbackSingnalledEnd = true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                validateResults(results, expectedOrderIds);
            });
        };
        const validateQueryMetrics = function (queryIterator) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    while (queryIterator.hasMoreResults()) {
                        const { result: results, headers } = yield queryIterator.executeNext();
                        if (results === undefined) {
                            break;
                        }
                        assert.notEqual(headers[__1.Constants.HttpHeaders.QueryMetrics], null);
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const executeQueryAndValidateResults = function (query, options, expectedOrderIds, validateExecuteNextWithContinuationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                options.populateQueryMetrics = true;
                validateExecuteNextWithContinuationToken = validateExecuteNextWithContinuationToken || false;
                const queryIterator = container.items.query(query, options);
                yield validateToArray(queryIterator, options, expectedOrderIds);
                queryIterator.reset();
                yield validateExecuteNextAndHasMoreResults(options, queryIterator, expectedOrderIds, validateExecuteNextWithContinuationToken);
                queryIterator.reset();
                yield validateNextItemAndCurrentAndHasMoreResults(queryIterator, expectedOrderIds);
                yield validateForEach(queryIterator, expectedOrderIds);
                yield validateQueryMetrics(queryIterator);
            });
        };
        const requestChargeValidator = function (queryIterator) {
            return __awaiter(this, void 0, void 0, function* () {
                let counter = 0;
                let totalRequestCharge = 0;
                while (queryIterator.hasMoreResults()) {
                    const { result: results, headers } = yield queryIterator.executeNext();
                    const rc = (headers || {})[__1.Constants.HttpHeaders.RequestCharge];
                    if (counter === 0) {
                        assert(rc > 0);
                        counter += 1;
                    }
                    if (results === undefined) {
                        assert(totalRequestCharge > 0);
                        return;
                    }
                    else {
                        totalRequestCharge += rc;
                        assert(rc >= 0);
                    }
                }
            });
        };
        it("Validate Parallel Query As String With maxDegreeOfParallelism = 0", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 0
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = [1, 10, 18, 2, 3, 13, 14, 16, 17, 0, 11, 12, 5, 9, 19, 4, 6, 7, 8, 15];
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds, false);
            });
        });
        it("Validate Parallel Query As String With maxDegreeOfParallelism: -1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: -1,
                    populateQueryMetrics: true
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = [1, 10, 18, 2, 3, 13, 14, 16, 17, 0, 11, 12, 5, 9, 19, 4, 6, 7, 8, 15];
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds, false);
            });
        });
        it("Validate Parallel Query As String With maxDegreeOfParallelism: 1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 1
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = [1, 10, 18, 2, 3, 13, 14, 16, 17, 0, 11, 12, 5, 9, 19, 4, 6, 7, 8, 15];
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds, false);
            });
        });
        it("Validate Parallel Query As String With maxDegreeOfParallelism: 3", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 3
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = [1, 10, 18, 2, 3, 13, 14, 16, 17, 0, 11, 12, 5, 9, 19, 4, 6, 7, 8, 15];
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds, false);
            });
        });
        it("Validate Parallel Query Request Charge With maxDegreeOfParallelism: 3", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 3
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Parallel Query Request Charge With maxDegreeOfParallelism: 1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 1
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Simple OrderBy Query Request Charge With maxDegreeOfParallelism = 1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 1
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Simple OrderBy Query Request Charge With maxDegreeOfParallelism = 0", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 0
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Top Query Request Charge with maxDegreeOfParallelism = 3", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 6;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const query = util.format("SELECT top %d * FROM root r", topCount);
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 3
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Top Query Request Charge with maxDegreeOfParallelism = 0", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 6;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const query = util.format("SELECT top %d * FROM root r", topCount);
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 0
                };
                const queryIterator = container.items.query(query, options);
                yield requestChargeValidator(queryIterator);
            });
        });
        it("Validate Simple OrderBy Query As String With maxDegreeOfParallelism = 0", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 0
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate Simple OrderBy Query As String With maxDegreeOfParallelism = 1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 1
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate Simple OrderBy Query As String With maxDegreeOfParallelism = 3", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 3
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate Simple OrderBy Query As String With maxDegreeOfParallelism = -1", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: -1
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate Simple OrderBy Query As String", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate Simple OrderBy Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query
                const querySpec = {
                    query: "SELECT * FROM root r order by r.spam"
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy Query With ASC", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // an order by query with explicit ascending ordering
                const querySpec = {
                    query: "SELECT * FROM root r order by r.spam ASC"
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy Query With DESC", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // an order by query with explicit descending ordering
                const querySpec = {
                    query: "SELECT * FROM root r order by r.spam DESC"
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey)
                    .map(function (r) {
                    return r["id"];
                })
                    .reverse();
                // validates the results size and order
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy with top", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // an order by query with top, total existing docs more than requested top count
                const topCount = 9;
                const querySpec = {
                    query: util.format("SELECT top %d * FROM root r order by r.spam", topCount)
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey)
                    .map(function (r) {
                    return r["id"];
                })
                    .slice(0, topCount);
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy with Top Query (less results than top counts)", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // an order by query with top, total existing docs less than requested top count
                const topCount = 30;
                // sanity check
                assert(topCount > documentDefinitions.length, "test setup is wrong");
                const querySpec = {
                    query: util.format("SELECT top %d * FROM root r order by r.spam", topCount)
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate Top Query with maxDegreeOfParallelism = 3", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 6;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const query = util.format("SELECT top %d * FROM root r", topCount);
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2,
                    maxDegreeOfParallelism: 3
                };
                // prepare expected behaviour verifier
                const queryIterator = container.items.query(query, options);
                const { result: results } = yield queryIterator.toArray();
                assert.equal(results.length, topCount);
                // select unique ids
                const uniqueIds = {};
                results.forEach(function (item) {
                    uniqueIds[item.id] = true;
                });
                // assert no duplicate results
                assert.equal(results.length, Object.keys(uniqueIds).length);
            });
        });
        it("Validate Top Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 6;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const query = util.format("SELECT top %d * FROM root r", topCount);
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected behaviour verifier
                const queryIterator = container.items.query(query, options);
                const { result: results } = yield queryIterator.toArray();
                assert.equal(results.length, topCount);
                // select unique ids
                const uniqueIds = {};
                results.forEach(item => {
                    uniqueIds[item.id] = true;
                });
                // assert no duplicate results
                assert.equal(results.length, Object.keys(uniqueIds).length);
            });
        });
        it("Validate Top Query (with 0 topCount)", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 0;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const query = util.format("SELECT top %d * FROM root r", topCount);
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected behaviour verifier
                const queryIterator = container.items.query(query, options);
                const { result: results } = yield queryIterator.toArray();
                assert.equal(results.length, topCount);
                // select unique ids
                const uniqueIds = {};
                results.forEach(item => {
                    uniqueIds[item.id] = true;
                });
                // assert no duplicate results
                assert.equal(results.length, Object.keys(uniqueIds).length);
            });
        });
        it("Validate Parametrized Top Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a top query
                const topCount = 6;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                const querySpec = {
                    query: "SELECT top @n * FROM root r",
                    parameters: [{ name: "@n", value: topCount }]
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected behaviour verifier
                const queryIterator = container.items.query(querySpec, options);
                const { result: results } = yield queryIterator.toArray();
                assert.equal(results.length, topCount);
                // select unique ids
                const uniqueIds = {};
                results.forEach(item => {
                    uniqueIds[item.id] = true;
                });
                // assert no duplicate results
                assert.equal(results.length, Object.keys(uniqueIds).length);
            });
        });
        it("Validate OrderBy with Parametrized Top Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // a parametrized top order by query
                const topCount = 9;
                // sanity check
                assert(topCount < documentDefinitions.length, "test setup is wrong");
                // a parametrized top order by query
                const querySpec = {
                    query: "SELECT top @n * FROM root r order by r.spam",
                    parameters: [{ name: "@n", value: topCount }]
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey)
                    .map(function (r) {
                    return r["id"];
                })
                    .slice(0, topCount);
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy with Parametrized Predicate", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // an order by query combined with parametrized predicate
                const querySpec = {
                    query: "SELECT * FROM root r where r.cnt > @cnt order by r.spam",
                    parameters: [{ name: "@cnt", value: 5 }]
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey)
                    .filter(function (r) {
                    return r["cnt"] > 5;
                })
                    .map(function (r) {
                    return r["id"];
                });
                yield executeQueryAndValidateResults(querySpec, options, expectedOrderedIds);
            });
        });
        it("Validate Error Handling - Orderby where types are noncomparable", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // test orderby with different order by item type
                // an order by query
                const query = {
                    query: "SELECT * FROM root r order by r.spam2"
                };
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected behaviour verifier
                try {
                    const queryIterator = container.items.query(query, options);
                    yield queryIterator.toArray();
                }
                catch (err) {
                    assert.notEqual(err, undefined);
                }
            });
        });
        it("Validate OrderBy Integer Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.cnt";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["cnt"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy Floating Point Number Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.number";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["number"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                // validates the results size and order
                yield executeQueryAndValidateResults(query, options, expectedOrderedIds);
            });
        });
        it("Validate OrderBy Boolean Query", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.boolVar";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                const queryIterator = container.items.query(query, options);
                const { result: results } = yield queryIterator.toArray();
                assert.equal(results.length, documentDefinitions.length);
                let index = 0;
                while (index < results.length) {
                    if (results[index].boolVar) {
                        break;
                    }
                    assert(results[index].id % 2 === 1);
                    index++;
                }
                while (index < results.length) {
                    assert(results[index].boolVar);
                    assert(results[index].id % 2 === 0);
                    index++;
                }
            });
        });
        it("Validate Failure", function () {
            return __awaiter(this, void 0, void 0, function* () {
                // simple order by query in string format
                const query = "SELECT * FROM root r order by r.spam";
                const options = {
                    enableCrossPartitionQuery: true,
                    maxItemCount: 2
                };
                // prepare expected results
                const getOrderByKey = function (r) {
                    return r["spam"];
                };
                const expectedOrderedIds = _.sortBy(documentDefinitions, getOrderByKey).map(function (r) {
                    return r["id"];
                });
                const queryIterator = container.items.query(query, options);
                let firstTime = true;
                const { result } = yield queryIterator.current();
                if (firstTime) {
                    firstTime = false;
                }
            });
        });
    });
});
//# sourceMappingURL=crossPartition.spec.js.map