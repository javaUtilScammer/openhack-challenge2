"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const __1 = require("../..");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
describe("Authorization", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    // TODO: should have types for all these things
    let database;
    let container;
    let userReadDefinition = { id: "User With Read Permission" };
    let userAllDefinition = { id: "User With All Permission" };
    let collReadPermission = {
        id: "container Read Permission",
        permissionMode: __1.DocumentBase.PermissionMode.Read
    };
    let collAllPermission = {
        id: "container All Permission",
        permissionMode: __1.DocumentBase.PermissionMode.All
    };
    /************** TEST **************/
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
            // create a database & container
            container = yield TestHelpers_1.getTestContainer("Authorization tests");
            database = container.database;
            // create userReadPermission
            const { body: userDef } = yield container.database.users.create(userReadDefinition);
            assert.equal(userReadDefinition.id, userDef.id, "userReadPermission is not created properly");
            userReadDefinition = userDef;
            const userRead = container.database.user(userDef.id);
            // give permission to read container, to userReadPermission
            collReadPermission.resource = container.url;
            const { body: readPermission } = yield userRead.permissions.create(collReadPermission);
            assert.equal(readPermission.id, collReadPermission.id, "permission to read coll1 is not created properly");
            collReadPermission = readPermission;
            // create userAllPermission
            const { body: userAllDef } = yield container.database.users.create(userAllDefinition);
            assert.equal(userAllDefinition.id, userAllDef.id, "userAllPermission is not created properly");
            userAllDefinition = userAllDef;
            const userAll = container.database.user(userAllDef.id);
            // create collAllPermission
            collAllPermission.resource = container.url;
            const { body: allPermission } = yield userAll.permissions.create(collAllPermission);
            assert.equal(collAllPermission.id, allPermission.id, "permission to read coll2 is not created properly");
            collAllPermission = allPermission;
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    it("Accessing container by resourceTokens", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const rTokens = {};
            rTokens[container.id] = collReadPermission._token;
            const clientReadPermission = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { resourceTokens: rTokens }
            });
            const { body: coll } = yield clientReadPermission
                .database(database.id)
                .container(container.id)
                .read();
            assert.equal(coll.id, container.id, "invalid container");
        });
    });
    it("Accessing container by permissionFeed", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const clientReadPermission = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { permissionFeed: [collReadPermission] }
            });
            // self link must be used to access a resource using permissionFeed
            const { body: coll } = yield clientReadPermission
                .database(database.id)
                .container(container.id)
                .read();
            assert.equal(coll.id, container.id, "invalid container");
        });
    });
    it("Accessing container without permission fails", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const clientNoPermission = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: null });
            try {
                yield clientNoPermission
                    .database(database.id)
                    .container(container.id)
                    .read();
                assert.fail("accessing container did not throw");
            }
            catch (err) {
                assert(err !== undefined); // TODO: should check that we get the right error message
            }
        });
    });
    it("Accessing document by permissionFeed of parent container", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const { body: createdDoc } = yield container.items.create({
                id: "document1"
            });
            const clientReadPermission = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { permissionFeed: [collReadPermission] }
            });
            assert.equal("document1", createdDoc.id, "invalid documnet create");
            const { body: readDoc } = yield clientReadPermission
                .database(database.id)
                .container(container.id)
                .item(createdDoc.id)
                .read();
            assert.equal(readDoc.id, createdDoc.id, "invalid document read");
        });
    });
    it("Modifying container by resourceTokens", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const rTokens = {};
            rTokens[container.id] = collAllPermission._token;
            const clientAllPermission = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { resourceTokens: rTokens }
            });
            // delete container
            return clientAllPermission
                .database(database.id)
                .container(container.id)
                .delete();
        });
    });
    it("Modifying container by permissionFeed", function () {
        return __awaiter(this, void 0, void 0, function* () {
            const clientAllPermission = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { permissionFeed: [collAllPermission] }
            });
            // self link must be used to access a resource using permissionFeed
            // delete container
            return clientAllPermission
                .database(database.id)
                .container(container.id)
                .delete();
        });
    });
});
//# sourceMappingURL=authorization.spec.js.map